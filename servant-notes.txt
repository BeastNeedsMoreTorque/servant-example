
- type level functions ((:>) and (:<|>))
	- TypeOperators extension


- type families (Server and ServerT)

- type level strings
	- proxy type
	- symbolVal :: KnownSymbol n => proxy n -> String

- type level lists

- example

```
instance (KnownSymbol path, HasServer sublayout) => HasServer (path :> sublayout) where
	type ServerT (path :> sublayout) m = ServerT sublayout m

	route Proxy subserver = StaticRouter $
		M.singleton (toText (symbolVal proxyPath))
					(route proxySublayout subserver)
      where
		proxyPath :: Proxy path
		proxyPath = Proxy

		proxySublayout :: Proxy sublayout
		proxySublayout = Proxy

		toText :: String -> Text
		toText string = cs string
```

----------------------------------------------------------------------------------------


Servant is a really nice library for building REST APIs in Haskell.  However,
it uses some advanced GHC features which may not be familiar to some Haskell
programmers.  In this article, I explain type-level strings, type-level lists,
type-level operators, and type families.  Finally, I use code from
servant-server to explain how these features are used in practice.

Servant Example
---------------

Here is a simple example of using servant-server.

```
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeOperators #-}

module Main where

import Control.Monad.Trans.Either (EitherT)
import Network.Wai (Application)
import Network.Wai.Handler.Warp (run)
import Network.Wai.Middleware.RequestLogger (logStdoutDev)
import Servant
    ( (:>), (:<|>)((:<|>)), Get, JSON, Proxy(..), ServantErr, ServerT, serve )

type MyAPI = "dogs" :> Get '[JSON] [Int]
        :<|> "cats" :> Get '[JSON] [String]

app :: Application
app = serve (Proxy :: Proxy MyAPI) myAPI

myAPI :: ServerT MyAPI (EitherT ServantErr IO)
myAPI = dogNums :<|> cats

dogNums :: EitherT ServantErr IO [Int]
dogNums = return [1,2,3,4]

cats :: EitherT ServantErr IO [String]
cats = return ["long-haired", "short-haired"]

main :: IO ()
main = run 32323 $ logStdoutDev app
```

This example project can be found at the gist https://gist.github.com/cdepillabout/c2b8b1807e1f571fdb45#file-example-hs

The following steps can be used to download and run the code.  The stack build tool is used.

```
$ git clone https://gist.github.com/c2b8b1807e1f571fdb45.git
$ mv c2b8b1807e1f571fdb45 small-servant-example
$ cd small-servant-example
$ stack build
$ stack exec servant-notes
```

This runs a Warp server on port 32323.  With the server running, you can use curl to test the API.

```
$ curl http://localhost:32323/dogs
[1,2,3,4]
$ curl http://localhost:32323/cats
["long-haired","short-haired"]
$
```

You can also open the code in ghci.

```
$ stack ghci
ghci> :load example.hs
ghci> :info app
app :: Application      -- Defined at example.hs:17:1
ghci>
```

Type-Level Strings
------------------




Type-Level Lists
----------------


Type-Level Operators
--------------------

In the servant example code above, there are two type-level operators being used: (:>) and (:<|>).  Type-level operators are similar to normal data types.  They are just composed of symbols instead of letters.

Let's look at how (:>) and (:<|>) are defined in servant:

```
data path :> a

data a :<|> b = a :<|> b
```

If we didn't want to write them infix, we could write them like this:

```
data (:>) path a

data (:<|>) a b = (:<|>) a b
```

In fact, if we were to write these data types with letters instead of symbols, it would look something like this:

```
data Foo path a

data Bar a b = Bar a b
```

You can see that (:>) and (:<|>) are just normal datatype definitions. They look weird because they are made of symbols and written infix.

Type operators help us write long type definitions that are easy to understand.  Take the following API definition:

```
type MyAPI = "foo" :> "bar" >: Get '[JSON] [Int]
```

Rewriting this prefix would look like this:

```
type MyAPI = (:>) "foo" ((>:) "bar" (Get '[JSON] [Int]))
```

You can see how much easier the infix style is to read!

NOTE:  You need the TypeOperators language extension enabled to use the above code.

https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/data-type-extensions.html#type-operators

You may be thinking, "These type operators are pretty neat, but how are they actually used?  They just look like confusing data types!"  Well, we'll get to that in a minute.  First  we need to take a look at type families.

Type Families
-------------

Type families are a relatively simple addition to Haskell that allow the user to do some computation at the type level.  However, if you google for "type families" (TODO: link to google here), it's easy to get scared.

https://www.google.co.jp/search?q=haskell+type+families&ie=utf-8&oe=utf-8&gws_rd=cr&ei=OzuSVZSMA6S-mAX044aoCQ

The first result is the GHC/Type families article on the Haskell wiki (https://wiki.haskell.org/GHC/Type_families).  This is written with an advanced Haskeller in mind.  Don't worry if it goes completely over your head.  (The other problem is that most of their examples use data families instead of type families--which I introduce below.  Most of the realworld Haskell code I've seen uses type families much more than data families).

The second link is to the GHC manual.  It's good if you already know about type families and just want a refresher, but it's not good if you just an introduction to type families.  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-families.html

The third result is https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/type-families-and-pokemon an article on fpcomplete.  It gets points for being about Pokemon, but the setup/motivation for using type families is way too long.

The fourth result is an introduction to type families from O'Charles (https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html).  It's the best of the bunch, but it is slightly hard to follow if you've never used MVars, IORefs, etc.

I wrote a super simple tl;dr presentation about type families.  https://cdepillabout.github.io/haskell-type-families-presentation
Originally I wrote it in Japanese for a Haskell Lightening Talk in Tokyo, but I recently translated it to English upon the request from someone in the #haskell room in the functional programming slack community (http://fpchat.com/).  If you aren't sure about type families, please read that presentation and then proceed to the next section.  We will be talking about the ServantT type familiy.


Servant
-------

So now we come to how servant actually uses these things.  Let's go back to the example code at the top of this blog post:


```
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeOperators #-}

module Main where

import Control.Monad.Trans.Either (EitherT)
import Network.Wai (Application)
import Network.Wai.Handler.Warp (run)
import Network.Wai.Middleware.RequestLogger (logStdoutDev)
import Servant
    ( (:>), (:<|>)((:<|>)), Get, JSON, Proxy(..), ServantErr, ServerT, serve )

type MyAPI = "dogs" :> Get '[JSON] [Int]
        :<|> "cats" :> Get '[JSON] [String]

app :: Application
app = serve (Proxy :: Proxy MyAPI) myAPI

myAPI :: ServerT MyAPI (EitherT ServantErr IO)
myAPI = dogNums :<|> cats

dogNums :: EitherT ServantErr IO [Int]
dogNums = return [1,2,3,4]

cats :: EitherT ServantErr IO [String]
cats = return ["long-haired", "short-haired"]

main :: IO ()
main = run 32323 $ logStdoutDev app
```

The two interesting functions are serve and myAPI.  serve is provided by servant-server, while myAPI is written by us.

Let's look at the type of serve:

```
ghci> import Servant.Server
ghci> :type serve
serve :: HasServer layout => Proxy layout
						  -> Server layout
						  -> Network.Wai.Application 
```

Let's start with the easy things.  You can see that it returns a 'Network.Wai.Application'.  This represents an application that can that can be served by Warp (i.e. something that can be passed to the 'run' function).

The first argument is Proxy layout.  This is how we tell the serve function what our API type is.  You might be asking, "If we are also passing the layout type variable to the Server type constructor, why do we additionally need to pass a Proxy layout?  Surely, we don't need to pass it twice?".  That will be covered later.

(If you don't understand this, look at the type of the serve function again:

```
serve :: HasServer layout => Proxy <b>layout</b>
						  -> Server </b>layout</b>
						  -> Network.Wai.Application 
```

layout is specified twice, when it should only have to be specified once, right?)

Now look at the second argument, Server layout.  What is Server?

```
ghci> :info! Server
type Server layout =
	ServerT layout (EitherT ServantErr IO)
```

Server looks like it is a specialization of ServerT around the EitherT


Conclusion
----------

If you liked this tutorial, you may also like the servant tutorial itself
(http://haskell-servant.github.io/tutorial/), or a tutorial about using servant
with persistent
(http://www.parsonsmatt.org/programming/2015/06/07/servant-persistent.html) by
Matt Parsons (http://www.parsonsmatt.org/).
