
- type level functions ((:>) and (:<|>))
	- TypeOperators extension


- type families (Server and ServerT)

- type level strings
	- proxy type
	- symbolVal :: KnownSymbol n => proxy n -> String

- type level lists

- example

```
instance (KnownSymbol path, HasServer sublayout) => HasServer (path :> sublayout) where
	type ServerT (path :> sublayout) m = ServerT sublayout m

	route Proxy subserver = StaticRouter $
		M.singleton (toText (symbolVal proxyPath))
					(route proxySublayout subserver)
      where
		proxyPath :: Proxy path
		proxyPath = Proxy

		proxySublayout :: Proxy sublayout
		proxySublayout = Proxy

		toText :: String -> Text
		toText string = cs string
```

----------------------------------------------------------------------------------------


Servant is a really nice library for building REST APIs in Haskell.  However,
it uses some advanced GHC features which may not be familiar to some Haskell
programmers.  In this article, I explain type-level strings, type-level lists,
type-level operators, and type families.  Finally, I use code from
servant-server to explain how these features are used in practice.

Servant Example
---------------

Here is a simple example of using servant-server.

```
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeOperators #-}

module Main where

import Control.Monad.Trans.Either (EitherT)
import Network.Wai (Application)
import Network.Wai.Handler.Warp (run)
import Network.Wai.Middleware.RequestLogger (logStdoutDev)
import Servant
    ( (:>), (:<|>)((:<|>)), Get, JSON, Proxy(..), ServantErr, ServerT, serve )

type MyAPI = "dogs" :> Get '[JSON] [Int]
        :<|> "cats" :> Get '[JSON] [String]

app :: Application
app = serve (Proxy :: Proxy MyAPI) server

server :: ServerT MyAPI (EitherT ServantErr IO)
server = dogNums :<|> cats

dogNums :: EitherT ServantErr IO [Int]
dogNums = return [1,2,3,4]

cats :: EitherT ServantErr IO [String]
cats = return ["long-haired", "short-haired"]

main :: IO ()
main = run 32323 $ logStdoutDev app
```

This example project can be found at the gist https://gist.github.com/cdepillabout/c2b8b1807e1f571fdb45#file-example-hs

The following steps can be used to download and run the code.  The stack build tool is used.

```
$ git clone https://gist.github.com/c2b8b1807e1f571fdb45.git
$ mv c2b8b1807e1f571fdb45 small-servant-example
$ cd small-servant-example
$ stack build
$ stack exec servant-notes
```

This runs a Warp server on port 32323.  With the server running, you can use curl to test the API.

```
$ curl http://localhost:32323/dogs
[1,2,3,4]
$ curl http://localhost:32323/cats
["long-haired","short-haired"]
$
```

You can also open the code in ghci.

```
$ stack ghci
ghci> :load example.hs
ghci> :info app
app :: Application      -- Defined at example.hs:17:1
ghci>
```

Type-Level Strings
------------------




Type-Level Lists
----------------


Type-Level Operators
--------------------

In the servant example code above, there are two type-level operators being used: (:>) and (:<|>).  Type-level operators are similar to normal data types.  They are just composed of symbols instead of letters.

Let's look at how (:>) and (:<|>) are defined in servant:

data path :> a

data a :<|> b = a :<|> b


NOTE:  You need the TypeOperators language extension enabled to use the above code.

https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/data-type-extensions.html#type-operators

Type Families
-------------





Conclusion
----------

If you liked this tutorial, you may also like the servant tutorial itself
(http://haskell-servant.github.io/tutorial/), or a tutorial about using servant
with persistent
(http://www.parsonsmatt.org/programming/2015/06/07/servant-persistent.html) by
Matt Parsons (http://www.parsonsmatt.org/).
